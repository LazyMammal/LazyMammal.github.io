<!DOCTYPE html>
<html>

<head>
    <meta charset="utf-8">
    <script src="https://rawgit.com/kangax/fabric.js/master/dist/fabric.min.js"></script>
    <style>
        .diagram {
            margin: 3px;
        }

        .diagram canvas {
            border: 1px solid #ccc;
        }
    </style>
</head>

<body>
    <div class="diagram"> <canvas id="c_main" width="300" height="300"></canvas></div>
    <div class="diagram"> <canvas id="c_sdf" width="400" height="400"></canvas></div>
    <a href="javascript:location.reload(true)">Generate</a>
    <script>
        (function () {
            let c_main = new fabric.StaticCanvas('c_main');
            c_main.radius = Math.min(c_main.width / 2, c_main.height / 2);

            function makePolyline(points, options = null) {
                let defOpts = {
                    stroke: 'red',
                    strokeWidth: 3,
                    strokeLineCap: 'round',
                    strokeLineJoin: 'round',
                    fill: ''
                }
                const allOpts = Object.assign({}, defOpts, options);
                return new fabric.Polyline(points, allOpts);
            }

            function polarPoint(angle, dist) {
                return { x: dist * Math.sin(angle), y: dist * Math.cos(angle) };
            }

            function makeSquiggle(radius = null) {
                radius = radius || Math.random();
                let pts = [];

                // first point
                let a = Math.random() * Math.PI * 2;
                let r = radius;
                pts.push(polarPoint(a, r));

                // trailing segments
                let segs = Math.floor(Math.random() * 2) + 5;
                for (let i = 0; i < segs; i++) {
                    a += Math.PI / 16;
                    r += (Math.random() - .5) / 10;
                    pts.push(polarPoint(a, r));
                }

                return pts;
            }

            function makeRose() {
                let layers = [];
                const max_layers = 15;
                for (let i = 1; i <= max_layers; i++) {
                    layers.push(makeSquiggle(i / max_layers));
                }
                return layers;
            }

            function drawLayers(layers, x, y, scale) {
                let lines = [];
                for (let i = 0; i < layers.length; i++) {
                    let points = layers[i];
                    let scaledPoints = [];
                    for (let p = 0; p < points.length; p++) {
                        scaledPoints.push({ x: points[p].x * scale, y: points[p].y * scale });
                    }
                    lines.push(makePolyline(scaledPoints));
                }
                let group = new fabric.Group(lines, {
                    left: x,
                    top: y,
                    originY: 'center',
                    originX: 'center'
                });
                return group;
            }

            // make rose garden
            let roses = [];
            const count = 3;
            const cellX = c_main.width / count;
            const cellY = c_main.height / count;

            for (let y = 0; y < count; y++) {
                for (let x = 0; x < count; x++) {
                    let roseObj = {
                        rose: makeRose(),
                        x: (x + .5 + .25 * (Math.random() - .5)) * cellX,
                        y: (y + .5 + .25 * (Math.random() - .5)) * cellY,
                        scale: cellX / 2
                    };
                    roses.push(roseObj);
                    c_main.add(drawLayers(roseObj.rose, roseObj.x, roseObj.y, roseObj.scale));
                }
            }

            // get all individual line segments
            let allLines = [];
            let scale = cellX / 2;
            for (let r = 0; r < roses.length; r++) {
                let layers = roses[r].rose;
                for (let i = 0; i < layers.length; i++) {
                    let points = layers[i];
                    for (let p = 1; p < points.length; p++) {
                        let p1 = points[p - 1];
                        let p2 = points[p];
                        allLines.push([
                            { x: p1.x + roses[r].x / roses[r].scale, y: p1.y + roses[r].y / roses[r].scale },
                            { x: p2.x + roses[r].x / roses[r].scale, y: p2.y + roses[r].y / roses[r].scale }
                        ]);
                    }
                }
            }

        })();
    </script>
</body>

</html>