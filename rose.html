<!DOCTYPE html>
<html>

<head>
    <meta charset="utf-8">
    <script src="https://rawgit.com/kangax/fabric.js/master/dist/fabric.min.js"></script>
    <style>
        .diagram {
            margin: 3px;
        }

        .diagram canvas {
            border: 1px solid #ccc;
        }
    </style>
</head>

<body>
    <div class="diagram"> <canvas id="c_main" width="300" height="300"></canvas></div>
    <div class="diagram"> <canvas id="c_sdf" width="400" height="400"></canvas></div>
    <a href="javascript:location.reload(true)">Generate</a>
    <script>
        (function () {
            let c_main = new fabric.StaticCanvas('c_main');
            c_main.radius = Math.min(c_main.width / 2, c_main.height / 2);

            function makePolyline(points, options = null) {
                let defOpts = {
                    stroke: 'red',
                    strokeWidth: 3,
                    strokeLineCap: 'round',
                    strokeLineJoin: 'round',
                    fill: ''
                }
                const allOpts = Object.assign({}, defOpts, options);
                return new fabric.Polyline(points, allOpts);
            }

            function polarPoint(angle, dist) {
                return { x: dist * Math.sin(angle), y: dist * Math.cos(angle) };
            }

            function makeSquiggle(radius = null) {
                radius = radius || Math.random();
                let pts = [];

                // first point
                let a = Math.random() * Math.PI * 2;
                let r = radius;
                pts.push(polarPoint(a, r));

                // trailing segments
                let segs = Math.floor(Math.random() * 2) + 5;
                for (let i = 0; i < segs; i++) {
                    a += Math.PI / 16;
                    r += (Math.random() - .5) / 10;
                    pts.push(polarPoint(a, r));
                }

                return pts;
            }

            function makeRose() {
                let layers = [];
                const max_layers = 15;
                for (let i = 1; i <= max_layers; i++) {
                    layers.push(makeSquiggle(i / max_layers));
                }
                return layers;
            }

            function drawLayers(layers, x, y, scale) {
                let lines = [];
                for (let i = 0; i < layers.length; i++) {
                    let points = layers[i];
                    let scaledPoints = [];
                    for (let p = 0; p < points.length; p++) {
                        scaledPoints.push({ x: points[p].x * scale, y: points[p].y * scale });
                    }
                    lines.push(makePolyline(scaledPoints));
                }
                let group = new fabric.Group(lines, {
                    left: x,
                    top: y,
                    originY: 'center',
                    originX: 'center'
                });
                return group;
            }

            // make rose garden
            let roses = [];
            const count = 3;
            const cellX = c_main.width / count;
            const cellY = c_main.height / count;

            for (let y = 0; y < count; y++) {
                for (let x = 0; x < count; x++) {
                    let roseObj = {
                        rose: makeRose(),
                        x: (x + .5 + .25 * (Math.random() - .5)) * cellX,
                        y: (y + .5 + .25 * (Math.random() - .5)) * cellY,
                    };
                    roses.push(roseObj);
                    c_main.add(drawLayers(roseObj.rose, roseObj.x, roseObj.y, cellX / 2));
                }
            }

            function distToSegment(p, v, w) {
                let l2 = Math.pow(v.x - w.x, 2) + Math.pow(v.y - w.y, 2);
                if (l2 == 0)
                    return Math.pow(p.x - v.x, 2) + Math.pow(p.y - v.y, 2);
                let t = ((p.x - v.x) * (w.x - v.x) + (p.y - v.y) * (w.y - v.y)) / l2;
                t = Math.max(0, Math.min(1, t));
                return Math.sqrt(Math.pow(v.x + t * (w.x - v.x) - p.x, 2) + Math.pow(v.y + t * (w.y - v.y) - p.y, 2));
            }

            // from here using Canvas directly (not FabricJS)
            let canvas = document.getElementById('c_sdf');
            let ctx = canvas.getContext('2d');
            let imageData = ctx.createImageData(canvas.width, canvas.height);

            let t1 = performance.now();

            // get all individual line segments
            let allLines = [];
            let scale = cellX / 2;
            for (let r = 0; r < roses.length; r++) {
                let layers = roses[r].rose;
                for (let i = 0; i < layers.length; i++) {
                    let points = layers[i];
                    for (let p = 1; p < points.length; p++) {
                        let p1 = points[p - 1];
                        let p2 = points[p];
                        allLines.push([
                            { x: p1.x + roses[r].x / scale, y: p1.y + roses[r].y / scale },
                            { x: p2.x + roses[r].x / scale, y: p2.y + roses[r].y / scale }
                        ]);
                    }
                }
            }

            // Iterate through every pixel
            let i = 0;
            let max_d = null;
            for (let y = 0; y < canvas.height; y++) {
                for (let x = 0; x < canvas.width && i < imageData.data.length; x++) {

                    let p = { x: x / scale - 1, y: y / scale - 1};

                    let d = 1000;
                    for (let i = 0; i < allLines.length; i++) {
                        let points = allLines[i];
                        d = Math.min(d, distToSegment(p, points[0], points[1]));
                    }

                    if (i == 0 || d > max_d) {
                        max_d = d;
                        //console.log({ x: x, y: y, d: d });
                    }

                    let c = Math.min(255, Math.floor((1 - d) * 256));

                    // Modify pixel data
                    imageData.data[i + 0] = c;  // R value
                    imageData.data[i + 1] = c;  // G value
                    imageData.data[i + 2] = c;  // B value
                    imageData.data[i + 3] = 255;  // A value

                    i += 4; // stride of pixel struct
                }
            }
            let t2 = performance.now();
            console.log(imageData);
            console.log(t2 - t1);
            console.log(['max_d', max_d])

            ctx.putImageData(imageData, 0, 0);

        })();
    </script>
</body>

</html>