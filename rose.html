<!DOCTYPE html>
<html>

<head>
    <meta charset="utf-8">
    <script src="https://rawgit.com/kangax/fabric.js/master/dist/fabric.min.js"></script>
    <style>
        .diagram {
            margin: 3px;
        }

        .diagram canvas {
            border: 1px solid #ccc;
        }
    </style>
</head>

<body>
    <div class="diagram"> <canvas id="c_main" width="300" height="300"></canvas></div>
    <div class="diagram"> <canvas id="c_rose" width="300" height="100"></canvas></div>
    <a href="javascript:location.reload(true)">Generate</a>
    <script>
        (function () {
            var c_main = new fabric.StaticCanvas('c_main');

            c_main.radius = Math.min(c_main.width / 2, c_main.height / 2);
            c_main.add(new fabric.Circle(
                {
                    top: c_main.width / 2,
                    left: c_main.height / 2,
                    radius: c_main.radius,
                    stroke: 'black',
                    strokeWidth: 1,
                    opacity: .5,
                    fill: '',
                    originY: 'center',
                    originX: 'center'
                }));

            function makePolyline(points, options = null) {
                var defOpts = {
                    stroke: 'red',
                    strokeWidth: 3,
                    strokeLineCap: 'round',
                    strokeLineJoin: 'round',
                    fill: ''
                }
                const allOpts = Object.assign({}, defOpts, options);
                return new fabric.Polyline(points, allOpts);
            }

            function polarPoint(angle, dist) {
                return { x: dist * Math.sin(angle), y: dist * Math.cos(angle) };
            }

            function makeSquiggle(radius = null) {
                radius = radius || Math.random();
                var pts = [];

                // first point
                var a = Math.random() * Math.PI * 2;
                var r = radius;
                pts.push(polarPoint(a, r));

                // trailing segments
                var segs = Math.floor(Math.random() * 2) + 5;
                for (var i = 0; i < segs; i++) {
                    a += Math.PI / 16;
                    r += (Math.random() - .5) / 10;
                    pts.push(polarPoint(a, r));
                }

                return pts;
            }

            function makeRose() {
                var layers = [];
                const max_layers = 15;
                for (var i = 1; i <= max_layers; i++) {
                    layers.push(makeSquiggle(i / max_layers));
                }
                return layers;
            }
            var roseLayers = makeRose();

            function drawLayers(layers, x, y, scale) {
                var lines = [];
                for (var i = 0; i < layers.length; i++) {
                    var points = layers[i];
                    var scaledPoints = [];
                    for( var p =0; p < points.length; p++){
                        scaledPoints.push({x: points[p].x * scale, y: points[p].y * scale});
                    }
                    lines.push(makePolyline(scaledPoints));
                }
                var group = new fabric.Group(lines, {
                    left: x,
                    top: y,
                    originY: 'center',
                    originX: 'center'
                });
                return group;
            }
            c_main.add(drawLayers(roseLayers, c_main.width / 2, c_main.height / 2, c_main.radius));
            
            var c_rose = new fabric.StaticCanvas('c_rose');
            c_rose.radius = Math.min(c_rose.width / 2, c_rose.height / 2);
            c_rose.add(drawLayers(roseLayers, c_rose.width / 6, c_rose.height / 2, c_rose.radius));
            c_rose.add(drawLayers(roseLayers, c_rose.width / 2, c_rose.height / 2, c_rose.radius));
            c_rose.add(drawLayers(roseLayers, 5 * c_rose.width / 6, c_rose.height / 2, c_rose.radius));

        })();
    </script>
</body>

</html>